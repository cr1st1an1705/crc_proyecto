from typing import List, Tuple

def bits_from_bytes(data: bytes) -> List[int]:
    bits: List[int] = []
    for b in data:
        for i in range(7, -1, -1):
            bits.append((b >> i) & 1)
    return bits

def bytes_from_bits(bits: List[int]) -> bytes:
    out = bytearray()
    for i in range(0, len(bits), 8):
        chunk = bits[i:i+8]
        v = 0
        for bit in chunk:
            v = (v << 1) | (bit & 1)
        pad = (8 - len(chunk)) % 8
        v = v << pad
        out.append(v)
    return bytes(out)

def is_bitstring(s: str) -> bool:
    s2 = s.replace(" ", "")
    return len(s2) > 0 and set(s2) <= {"0", "1"}

def parse_bitstring(s: str) -> bytes:
    s2 = s.replace(" ", "")
    bits = [(1 if c == "1" else 0) for c in s2]
    return bytes_from_bits(bits)

def crc_calc(data: bytes, poly_bits: str, init: int = 0) -> int:
    n = len(poly_bits)
    if n < 1 or n > 8:
        raise ValueError("POLY_BITS debe tener entre 1 y 8 bits")
    mask = (1 << n) - 1
    poly = int(poly_bits, 2) & mask
    reg = init & mask
    for bit in bits_from_bytes(data):
        msb = (reg >> (n - 1)) & 1
        reg = ((reg << 1) & mask) | (bit & 1)
        if msb:
            reg ^= poly
    return reg & mask

def pack_lowbits(msg: bytes, poly_bits: str) -> Tuple[bytes, int]:
    n = len(poly_bits)
    crc = crc_calc(msg, poly_bits)
    last = crc & ((1 << n) - 1)
    return msg + bytes([last]), crc

def unpack_and_verify(frame: bytes, poly_bits: str):
    n = len(poly_bits)
    if not frame:
        raise ValueError("frame vacío")
    crc_recv = frame[-1] & ((1 << n) - 1)
    payload = frame[:-1]
    calc = crc_calc(payload, poly_bits)
    ok = (calc == crc_recv)
    return {
        "ok": ok,
        "payload": payload,
        "crc_recv": crc_recv,
        "crc_calc": calc,
        "n": n,
        "poly_bits": poly_bits,
        "payload_bits": "".join(str(b) for b in bits_from_bytes(payload)),
        "crc_recv_bits": format(crc_recv, f"0{n}b"),
        "crc_calc_bits": format(calc, f"0{n}b"),
    }

def explain_crc_steps(data: bytes, poly_bits: str) -> str:
    """Retorna un texto con el proceso LFSR paso a paso, consistente con crc_calc()."""
    n = len(poly_bits)
    if n < 1 or n > 8:
        raise ValueError("POLY_BITS debe tener entre 1 y 8 bits")
    mask = (1 << n) - 1
    poly = int(poly_bits, 2) & mask
    reg = 0

    def _bits(d: bytes):
        for b in d:
            for i in range(7, -1, -1):
                yield (b >> i) & 1

    bits_in = "".join(str(b) for b in _bits(data))
    lines = []
    lines.append(f"polinomio: {poly_bits}  (n={n})")
    lines.append(f"bits de entrada: {bits_in}")
    lines.append(f"reg inicial: {format(reg, f'0{n}b')}\n")

    step = 0
    for bit in _bits(data):
        msb = (reg >> (n - 1)) & 1
        shifted = ((reg << 1) & mask) | (bit & 1)
        if msb:
            reg = shifted ^ poly
            action = f"XOR poly ({poly_bits})"
        else:
            reg = shifted
            action = "sin XOR"
        step += 1
        lines.append(
            f"paso {step:02d}: in={bit} msb={msb}  shift={format(shifted, f'0{n}b')}  -> {action}  reg={format(reg, f'0{n}b')}"
        )

    lines.append(f"\nresto final (CRC): {format(reg, f'0{n}b')}")
    return "\n".join(lines)


def explain_crc_long_division(data: bytes, poly_bits: str) -> str:
    """
    División binaria en GF(2) con presentación de resta apilada.
    Muestra el generador, la trama (datos + n ceros) y las restas alineadas.
    """
    n = len(poly_bits)
    if n < 1 or n > 8:
        raise ValueError("POLY_BITS debe tener entre 1 y 8 bits")
    divisor_bits = poly_bits
    divisor = int(divisor_bits, 2)

    # bits de la trama con n ceros añadidos
    def _bits(d: bytes):
        for b in d:
            for i in range(7, -1, -1):
                yield (b >> i) & 1
    dividend_bits = "".join(str(b) for b in _bits(data)) + "0"*n

    # trabajo como lista de '0'/'1'
    work = list(dividend_bits)
    L = len(work)

    lines = []
    lines.append(f"generador: {divisor_bits}")
    lines.append(f"trama:     {dividend_bits}\n")

    i = 0
    while i <= L - n:
        if work[i] == "1":
            # segmento actual y "resta" (XOR) del generador alineado
            segment = "".join(work[i:i+n])
            # resultado de la resta bit a bit
            res_bits = "".join("0" if segment[j] == divisor_bits[j] else "1" for j in range(n))
            # aplicar la resta al trabajo
            for j in range(n):
                work[i+j] = "0" if work[i+j] == divisor_bits[j] else "1"
            indent = " " * i
            lines.append(f"{indent}{segment}")
            lines.append(f"{indent}{divisor_bits}")
            lines.append(f"{indent}{'-'*n}")
            lines.append(f"{indent}{res_bits}\n")
        i += 1

    resto = "".join(work[-n:])
    lines.append(f"residuo:   {resto}")
    return "\n".join(lines)
def explain_crc_long_division_verify(frame: bytes, poly_bits: str) -> str:
    n = len(poly_bits)
    if n < 1 or n > 8:
        raise ValueError("POLY_BITS debe tener entre 1 y 8 bits")
    divisor_bits = poly_bits

    def _bits(d: bytes):
        for b in d:
            for i in range(7, -1, -1):
                yield (b >> i) & 1

    if not frame:
        return "trama vacia"

    # usar solo n bits del CRC (los mas bajos del ultimo byte)
    body = frame[:-1]
    last = frame[-1] & ((1 << n) - 1)
    dividend_bits = "".join(str(b) for b in _bits(body)) + format(last, f"0{n}b")

    work = list(dividend_bits)
    L = len(work)
    lines = []
    lines.append(f"generador: {divisor_bits}")
    lines.append(f"trama:     {dividend_bits}\n")

    i = 0
    while i <= L - n:
        if work[i] == "1":
            for j in range(n):
                work[i+j] = "0" if work[i+j] == divisor_bits[j] else "1"
            # solo visual
            segment = "".join(work[i:i+n])
            res_bits = "".join("0" if segment[j] == divisor_bits[j] else "1" for j in range(n))
            indent = " " * i
            lines.append(f"{indent}{segment}")
            lines.append(f"{indent}{divisor_bits}")
            lines.append(f"{indent}{'-'*n}")
            lines.append(f"{indent}{res_bits}\n")
        i += 1

    resto = "".join(work[-n:])
    ok_mark = "✅" if resto == "0"*n else "❌"
    lines.append(f"Residuo final = {resto} {ok_mark}")
    return "\n".join(lines)
